--基本指令--
	V-text
	V-html
	V-show
	V-if v-else v-else-if ： 结构必须相邻
	v-for
	V-on(@)
	V-bind(:)
	V-model => @input + :value
	V-cloak
	V-once: 渲染一次，低开销
--vue事件--
	V-on 简写 （@click）
	V-on:click
	事件对象event
	事件修饰符（可以串联）
		Stop  .prevent .capture .self .once  .passive
	v-model  .number .lazy .trim
	v-on:keyup.13
	了解 事件捕捉、事件冒泡（事件委托原理）
	StopPropagation   preventDetault
	原生事件方法attachEvent()采用冒泡方式，而addEventListener()可以采用冒泡或事件捕获方式。
--computed--
	计算属性缓存vs方法
    		计算属性是基于它们的响应式依赖进行缓存的只在相关响应式依赖发生改变时它们才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。
	计算属性的setter
    	两个钩子函数 get(),set()  
			计算属性的默认是用get，就是把值返回出来
				get: function () {
        		    return this.firstName + " " + this.lastName
        		}, 
			set定义一个参数是set值:
				set: function (value) { 参数value:是你要计算那个属性的值
        		      // 以空格切割 fullName 的值成一个数组
        		    var arr = value.split(" ");
        		      // 数组第一个值赋值给 firstName
        		    this.firstName = arr[0];
        		}

--watch--
    回调参数（newValue，oldValue）
        watch: {
            name(newVal, oldVal) {
                console.log('newVal:', newVal, '========', 'oldVal:', oldVal)
            }
        }
    监听对象、数组，handle、deep参数
    监听对象属性 对象键路径必须加上引号（’obj.name’）
    通过实例方法$watch 来监听数据
	vm.$watch('expOrFn',callback,[options])
--数组更新--
	Vue.set(vm.items, indexOfItem, newValue);
	vm.$set(vm.items, indexOfItem, newValue);
	vm.items.splice(indexOfItem, 1, newValue)
--对象更新--
	Vue.set(vm.obj, key, newValue)；
	Vue.delete(target,key);
	Object.assign({}, vm.obj, newObj);


